namespace AionUtils {
	using System;
	using System.Collections.Generic;
	using System.Linq;
	using System.Text;
	using System.Runtime.InteropServices;
	using BlueBlocksLib.FileAccess;
	using BlueBlocksLib.SetUtils;
	using System.IO;
	using Ionic.Zlib;
	using Ionic.Crc;

	// ported from pak2zip python script by roxfan
	public class PAKFile {

		public static void DeserializePakToDir(string pakfile, string dir) {
			PAKFile pak = new PAKFile(pakfile);
			if (!Directory.Exists(dir)) {
				Directory.CreateDirectory(dir);
			}
			foreach (var file in pak.Files) {
				string fullpath = Path.Combine(dir, file);
				string subDir = Path.GetDirectoryName(fullpath);
				Console.WriteLine("Unpacking {0}", file);
				if (!Directory.Exists(subDir)) {
					Directory.CreateDirectory(subDir);
				}
				System.IO.File.WriteAllBytes(fullpath, pak[file]);
			}
		}

		static string[] recursiveGetFiles(string dir, string prefix) {
			List<string> files = new List<string>();
			files.AddRange(Directory.GetFiles(dir).Select(x => prefix + Path.GetFileName(x)));

			var dirs = Directory.GetDirectories(dir);
			foreach (var subdir in dirs) {
				var dirname = Path.GetFileName(subdir);
				files.AddRange(recursiveGetFiles(subdir, prefix + dirname + "/"));
			}

			return files.ToArray();
		}

		public static void SerializeDirToPak(string dir, string pakfile) {
			string[] allFiles = recursiveGetFiles(dir, "");

			List<Dir> dirEntryList = new List<Dir>();

			using (FormattedWriter fw = new FormattedWriter(pakfile)) {
				// Write files
				foreach (var file in allFiles) {
					fw.Write(new Signature() { signature = stringFileHeader2 });
					File f = new File();
					byte[] bytes = System.IO.File.ReadAllBytes(Path.Combine(dir, file));
					byte[] compressed = decryptBytesWithTable(ZlibCodecCompress(bytes), 0x3ff, 1, table2);
					f.compressedSize = (uint)compressed.Length;
					f.compressionMethod = 8;
					CRC32 dataCheckSum = new CRC32();
					f.crc = dataCheckSum.GetCrc32(new MemoryStream(bytes));
					f.data = compressed;
					f.extractSystem = 0;
					f.extractVersion = 20;
					f.extraField = new byte[0];
					f.extraFieldLength = 0;
					f.filename = Encoding.UTF8.GetBytes(file);
					f.filenameLength = (ushort)f.filename.Length;
					f.generalPurposeFlagBits = 0;
					f.lastModDate = 0;
					f.lastModTime = 0;
					f.uncompressedSize = (uint)bytes.Length;
					fw.Write(f);

					Dir d = new Dir();
					d.comment = new byte[0];
					d.commentLength = 0;
					d.compressedSize = f.compressedSize;
					d.compressType = f.compressionMethod;
					d.crc = f.crc;
					d.createSystem = f.extractSystem;
					d.createVersion = f.extractVersion;
					d.date = f.lastModDate;
					d.diskNumberStart = 0;
					d.externalFileAttributes = 33;
					d.extractSystem = f.extractSystem;
					d.extractVersion = f.extractVersion;
					d.extraField = new byte[0];
					d.extraFieldLength = 0;
					d.filename = f.filename;
					d.filenameLength = f.filenameLength;
					d.flagBits = f.generalPurposeFlagBits;
					d.internalFileAttributes = 0;
					d.localHeaderOffset = 0;
					d.time = f.lastModTime;
					d.uncompressedSize = f.uncompressedSize;

					dirEntryList.Add(d);
				}

				var dirEntryListStartPos = fw.BaseStream.BaseStream.Position;
				foreach (var d in dirEntryList) {
					fw.Write(new Signature() { signature = stringCentralDir2 });
					fw.Write(d);
				}
				var dirEntryListEndPos = fw.BaseStream.BaseStream.Position;

				End e = new End();
				e.byteSizeOfCentralDirectory = (uint)(dirEntryListEndPos - dirEntryListStartPos);
				e.centralDirRecordsOnDisk = (short)dirEntryList.Count;
				e.centralDirStartDisk = 0;
				e.comment = new byte[0];
				e.commentLength = 0;
				e.diskNumber = 0;
				e.offsetOfStartOfCentralDirectory = (uint)dirEntryListStartPos;
				e.totalNumOfCentralDirRecords = (short)dirEntryList.Count;

				fw.Write(new Signature() { signature = stringEndArchive2 });
				fw.Write(e);
			}

		}

		// a PAK file is merely a zip file with some things tampered with, like
		// the first few bytes XOR'ed with a table and signatures that are not
		// the same as the standard zip file signatures

		[StructLayout(LayoutKind.Sequential)]
		struct Signature {
			[ArraySize(4)]
			public byte[] signature;
		}

		[StructLayout(LayoutKind.Sequential)]
		struct File {
			public byte extractVersion;

			public byte extractSystem;

			public ushort generalPurposeFlagBits;
			public ushort compressionMethod;
			public ushort lastModTime;
			public ushort lastModDate;

			public int crc;

			public uint compressedSize;
			public uint uncompressedSize;

			public ushort filenameLength;
			public ushort extraFieldLength;

			[ArraySize("filenameLength")]
			public byte[] filename;

			[ArraySize("extraFieldLength")]
			public byte[] extraField;

			[ArraySize("compressedSize")]
			public byte[] data;


			public string Filename {
				get {
					return Encoding.UTF8.GetString(filename);
				}
			}
		}

		[StructLayout(LayoutKind.Sequential)]
		struct Dir {
			public byte createVersion;
			public byte createSystem;
			public byte extractVersion;
			public byte extractSystem;

			public ushort flagBits;
			public ushort compressType;
			public ushort time;
			public ushort date;

			public int crc;

			public uint compressedSize;
			public uint uncompressedSize;

			public ushort filenameLength;
			public ushort extraFieldLength;
			public ushort commentLength;
			public ushort diskNumberStart;
			public ushort internalFileAttributes;

			public uint externalFileAttributes;
			public int localHeaderOffset;


			[ArraySize("filenameLength")]
			public byte[] filename;

			[ArraySize("extraFieldLength")]
			public byte[] extraField;

			[ArraySize("commentLength")]
			public byte[] comment;

			public string Filename {
				get {
					return Encoding.UTF8.GetString(filename);
				}
			}
		}

		[StructLayout(LayoutKind.Sequential)]
		struct End {
			public short diskNumber;
			public short centralDirStartDisk;
			public short centralDirRecordsOnDisk;
			public short totalNumOfCentralDirRecords;
			public uint byteSizeOfCentralDirectory;
			public uint offsetOfStartOfCentralDirectory;

			public ushort commentLength;

			[ArraySize("commentLength")]
			public byte[] comment;

		}

		static readonly byte[] stringFileHeader = { (byte)'P', (byte)'K', 3, 4 };
		static readonly byte[] stringFileHeader2 = { 0xaf, 0xb4, 0xfc, 0xfb };
		static readonly byte[] stringEndArchive2 = { 0xaF, 0xb4, 0xfa, 0xf9 };
		static readonly byte[] stringCentralDir2 = { 0xaF, 0xb4, 0xfe, 0xfd };

		int detectVersion(byte[] data, uint uncompressedSize, int crc, ushort compressionMethod) {

			if (compressionMethod != 0 && compressionMethod != 8) {
				throw new Exception("Unknown compression method " + compressionMethod + "!");
			}

			// version 2
			if (compressionMethod == 8) {
				try {
					var bytes = ZlibCodecDecompress(decryptBytesWithTable(data, 0x3ff, 1, table2));
					CRC32 dataCheckSum = new CRC32();
					int checkSum = dataCheckSum.GetCrc32(new MemoryStream(bytes));

					if (bytes.Length == uncompressedSize && checkSum == crc) {
						return 2;
					}
				} catch { }

			} else {
				var bytes = decryptBytesWithTable(data, 0x3ff, 1, table2);
				CRC32 dataCheckSum = new CRC32();
				int checkSum = dataCheckSum.GetCrc32(new MemoryStream(bytes));

				if (bytes.Length == uncompressedSize && checkSum == crc) {
					return 2;
				}
			}

			//version 1
			if (compressionMethod == 8) {
				try {
					var bytes = ZlibCodecDecompress(decryptBytesWithTable(data, 0x1f, 32, table1));

					CRC32 dataCheckSum = new CRC32();
					int checkSum = dataCheckSum.GetCrc32(new MemoryStream(bytes));

					if (bytes.Length == uncompressedSize && checkSum == crc) {
						return 1;
					}
				} catch { }

			} else {
				var bytes = decryptBytesWithTable(data, 0x1f, 32, table1);
				CRC32 dataCheckSum = new CRC32();
				int checkSum = dataCheckSum.GetCrc32(new MemoryStream(bytes));

				if (bytes.Length == uncompressedSize && checkSum == crc) {
					return 2;
				}
			}


			return 0;
		}

		static byte[] decryptBytesWithTable(byte[] data, int mask, int multiplier, byte[] table) {

			byte[] converted = new byte[data.Length];
			int csize = data.Length;
			
			int xorsize = 32;
			if (xorsize > csize) { xorsize = csize; }

			int tbloff = (csize & mask) * multiplier;

			Array.Copy(data, converted, data.Length);

			// only the first 32 bytes are XOR'ed. lame
			for (int i = 0; i < xorsize; i++) {
				converted[i] = (byte)(data[i] ^ table[tbloff + i]);
			}
			return converted;
		}

		private static byte[] ZlibCodecCompress(byte[] uncompressed) {
			int outputSize = 2048;
			byte[] output = new Byte[outputSize];
			int lengthToCompress = uncompressed.Length;

			// If you want a ZLIB stream, set this to true.  If you want
			// a bare DEFLATE stream, set this to false.
			bool wantRfc1950Header = false;

			using (MemoryStream ms = new MemoryStream()) {
				ZlibCodec compressor = new ZlibCodec();
				compressor.InitializeDeflate(CompressionLevel.BestCompression, wantRfc1950Header);

				compressor.InputBuffer = uncompressed;
				compressor.AvailableBytesIn = lengthToCompress;
				compressor.NextIn = 0;
				compressor.OutputBuffer = output;

				foreach (var f in new FlushType[] { FlushType.None, FlushType.Finish }) {
					int bytesToWrite = 0;
					do {
						compressor.AvailableBytesOut = outputSize;
						compressor.NextOut = 0;
						compressor.Deflate(f);

						bytesToWrite = outputSize - compressor.AvailableBytesOut;
						if (bytesToWrite > 0)
							ms.Write(output, 0, bytesToWrite);
					}
					while ((f == FlushType.None && (compressor.AvailableBytesIn != 0 || compressor.AvailableBytesOut == 0)) ||
						   (f == FlushType.Finish && bytesToWrite != 0));
				}

				compressor.EndDeflate();

				ms.Flush();
				return ms.ToArray();
			}
		}

		private static byte[] ZlibCodecDecompress(byte[] compressed) {

			int outputSize = 2048;
			byte[] output = new Byte[outputSize];

			// If you have a ZLIB stream, set this to true.  If you have
			// a bare DEFLATE stream, set this to false.
			bool expectRfc1950Header = false;

			using (MemoryStream ms = new MemoryStream()) {
				ZlibCodec compressor = new ZlibCodec();
				compressor.InitializeInflate(expectRfc1950Header);

				compressor.InputBuffer = compressed;
				compressor.AvailableBytesIn = compressed.Length;
				compressor.NextIn = 0;
				compressor.OutputBuffer = output;

				foreach (var f in new FlushType[] { FlushType.None, FlushType.Finish }) {
					int bytesToWrite = 0;
					do {
						compressor.AvailableBytesOut = outputSize;
						compressor.NextOut = 0;
						compressor.Inflate(f);

						bytesToWrite = outputSize - compressor.AvailableBytesOut;
						if (bytesToWrite > 0)
							ms.Write(output, 0, bytesToWrite);
					}
					while ((f == FlushType.None && (compressor.AvailableBytesIn != 0 || compressor.AvailableBytesOut == 0)) ||
					(f == FlushType.Finish && bytesToWrite != 0));
				}

				compressor.EndInflate();
				return ms.ToArray();
			}

		}

		int version = 0;
		Dictionary<string, File> files = new Dictionary<string, File>();

		public IEnumerable<string> Files {
			get {
				return files.Keys;
			}
		}

		public PAKFile(string filename) {

			FormattedReader pak = new FormattedReader(filename);

			while (true) {
				var sig = pak.Read<Signature>();

				if (ArrayUtils.AreEqual(sig.signature, stringFileHeader2)) {
					var header = pak.Read<File>();

					if (version == 0) {
						version = detectVersion(header.data, header.uncompressedSize, header.crc, header.compressionMethod);
						if (version == 0) {
							throw new Exception("Unknown AION version!");
						}
					}
					files[header.Filename.ToLower()] = header;

					Console.WriteLine("File: {0} Compression: {1}", header.Filename, header.compressionMethod);

				} else if (ArrayUtils.AreEqual(sig.signature, stringCentralDir2)) {
					var header = pak.Read<Dir>();

					Console.WriteLine("Dir: {0}", header.Filename);

				} else if (ArrayUtils.AreEqual(sig.signature, stringEndArchive2)) {
					var header = pak.Read<End>();

					Console.WriteLine("End disknumber {0}", header.diskNumber);

					break;
				} else {
					throw new Exception("bad sig");
				}
			}

		}

		public byte[] this[string filename] {
			get {
				if (version == 2) {
					if (files[filename.ToLower()].compressionMethod == 0x8) {
						return ZlibCodecDecompress(decryptBytesWithTable(files[filename.ToLower()].data, 0x3ff, 1, table2));
					} else {
						return decryptBytesWithTable(files[filename.ToLower()].data, 0x3ff, 1, table2);
					}
				} else {
					if (files[filename.ToLower()].compressionMethod == 0x8) {
						return ZlibCodecDecompress(decryptBytesWithTable(files[filename.ToLower()].data, 0x1f, 32, table1));
					} else {
						return decryptBytesWithTable(files[filename.ToLower()].data, 0x1f, 32, table1);
					}
				}
			}
		}


		// open beta
		static byte[] table1 = {
      0x2f, 0x5d, 0x51, 0xf7, 0x01, 0xe9, 0xb4, 0x93, 0x4e, 0x51, 0x81, 0x3e, 0xaf, 0x3f, 0xdf, 0x99,
      0x80, 0x5e, 0x13, 0x83, 0x9b, 0x46, 0x57, 0xb5, 0x1b, 0x5c, 0xec, 0xb1, 0x29, 0x7c, 0xa9, 0x31,
      0x68, 0xe5, 0xda, 0xa7, 0xf6, 0x4f, 0xae, 0x16, 0x9a, 0x7f, 0x03, 0xcf, 0x1d, 0x5e, 0xd0, 0x51,
      0x5a, 0xe5, 0x02, 0xd9, 0x11, 0xd0, 0xfb, 0xf4, 0xf8, 0x7c, 0xa2, 0x88, 0x26, 0xd8, 0x1f, 0xa2,
      0x43, 0xda, 0x33, 0xa9, 0xac, 0x4e, 0x5a, 0x0d, 0xed, 0x78, 0x86, 0x2d, 0xb2, 0x6a, 0xc4, 0x9b,
      0xaa, 0x77, 0x85, 0x57, 0x6a, 0xa6, 0xd8, 0x35, 0xd8, 0x97, 0x6b, 0x17, 0x24, 0xb7, 0x7a, 0x1d,
      0xd3, 0x3b, 0x9e, 0x79, 0xf2, 0xae, 0x9f, 0x01, 0xe6, 0x9d, 0x29, 0x40, 0xed, 0x2f, 0x9c, 0x16,
      0xda, 0x18, 0xd1, 0x99, 0x0e, 0xd4, 0x0a, 0x63, 0x2d, 0x92, 0xd7, 0xeb, 0xb4, 0xa7, 0x50, 0x21,
      0xd8, 0x0f, 0x45, 0xd6, 0xc6, 0xbf, 0xcc, 0x47, 0xcc, 0x59, 0xed, 0x3e, 0x71, 0xfe, 0xa0, 0x26,
      0xfc, 0xd1, 0x07, 0x85, 0x8a, 0xee, 0x12, 0x36, 0x11, 0x5a, 0x60, 0xe1, 0x8f, 0xbd, 0x9e, 0xf7,
      0xb6, 0x64, 0x39, 0xcd, 0x49, 0x5a, 0x9a, 0xf7, 0x90, 0x1c, 0xc1, 0xa2, 0x0b, 0xb3, 0x81, 0xf7,
      0xca, 0xb8, 0x2a, 0x4b, 0x95, 0x13, 0xdc, 0x2e, 0x4a, 0xe5, 0x64, 0x16, 0x94, 0x99, 0xc9, 0xb1,
      0x7b, 0x53, 0x76, 0xae, 0xc4, 0xdf, 0x26, 0xf7, 0xc8, 0x5f, 0x78, 0x31, 0xae, 0xaf, 0x5a, 0x7f,
      0xa4, 0xe7, 0x29, 0x5e, 0x0e, 0xe2, 0xbb, 0x91, 0x41, 0x32, 0x2c, 0xf0, 0xce, 0x60, 0x9e, 0x27,
      0xdc, 0xfa, 0xdc, 0x13, 0xac, 0x37, 0xf7, 0xf1, 0xb4, 0xa4, 0xcd, 0xf4, 0x7a, 0xdc, 0xa9, 0x7b,
      0x95, 0x82, 0xda, 0x7d, 0xfb, 0x8d, 0x6b, 0x6e, 0x0c, 0x43, 0xe7, 0x23, 0x6c, 0xc0, 0x53, 0xf9,
      0x39, 0x82, 0x38, 0xde, 0x9b, 0xd0, 0xfe, 0x57, 0x3d, 0x75, 0x65, 0x43, 0xb0, 0xae, 0x5a, 0x6e,
      0x4e, 0xb3, 0xfb, 0xae, 0x8c, 0xc4, 0x0f, 0x9b, 0x65, 0x27, 0xaf, 0xa2, 0xc6, 0xf1, 0x84, 0x91,
      0x94, 0x1a, 0x39, 0x39, 0x53, 0xa5, 0x90, 0x64, 0xf0, 0x62, 0xcc, 0xb5, 0xbf, 0x1e, 0xbc, 0xa7,
      0x28, 0xae, 0x33, 0x3f, 0x16, 0xc6, 0x30, 0xb7, 0xb1, 0xf2, 0x83, 0xb1, 0x5e, 0xb0, 0x37, 0x20,
      0x9d, 0xf7, 0x7b, 0x95, 0xbe, 0x35, 0x6e, 0x1b, 0x07, 0x05, 0x77, 0x32, 0x3a, 0xae, 0x8a, 0x39,
      0x25, 0xaf, 0x10, 0xc5, 0x18, 0x56, 0xc2, 0x2b, 0xf9, 0xc4, 0x4b, 0xd6, 0xdc, 0x44, 0xd7, 0x9d,
      0xa8, 0x5c, 0x7f, 0xad, 0xef, 0x88, 0xbc, 0x46, 0x5f, 0xfe, 0xc0, 0xe3, 0xde, 0x69, 0xe3, 0x03,
      0xed, 0xf8, 0x06, 0x1f, 0x38, 0xc1, 0x22, 0x23, 0xf4, 0xc1, 0xd7, 0xe1, 0x11, 0x7b, 0x3c, 0xcb,
      0xb4, 0x8d, 0xaf, 0x82, 0x23, 0x30, 0x0d, 0x78, 0x82, 0xf9, 0xed, 0x3e, 0x91, 0xe1, 0x52, 0xa7,
      0xd5, 0xd5, 0x75, 0x71, 0x46, 0xda, 0x11, 0x97, 0xfb, 0x16, 0xdf, 0xea, 0xf3, 0xab, 0xa0, 0x32,
      0x66, 0xdb, 0x5e, 0x5e, 0xb9, 0x43, 0x55, 0x0e, 0x9e, 0xa5, 0x2a, 0xfd, 0x5e, 0x31, 0xc6, 0x93,
      0xd4, 0x9a, 0xa2, 0x2b, 0x37, 0x00, 0xb9, 0x46, 0x13, 0xf7, 0x05, 0x51, 0xa7, 0xb2, 0xaa, 0x22,
      0x0c, 0x9d, 0xc5, 0xd2, 0x3d, 0x62, 0xf4, 0x28, 0x8c, 0xbc, 0x89, 0x25, 0x79, 0xfa, 0x9a, 0xfd,
      0x8d, 0xa1, 0xbc, 0x02, 0x2b, 0x15, 0xb0, 0xb6, 0xe6, 0xa4, 0xcd, 0xbc, 0x72, 0xf8, 0x68, 0xb4,
      0x9a, 0x33, 0x08, 0xba, 0x62, 0xb7, 0xb1, 0xb1, 0xca, 0x00, 0x08, 0x01, 0x40, 0x68, 0x8e, 0xe1,
      0x49, 0x4f, 0xd8, 0xf2, 0x67, 0x85, 0xf0, 0x37, 0xc9, 0x61, 0xab, 0x1e, 0xc6, 0x6a, 0x4d, 0xca,
      0xaf, 0x03, 0x2f, 0x36, 0x02, 0xf0, 0xbc, 0x5e, 0x81, 0x39, 0x8a, 0x25, 0x38, 0x2c, 0xca, 0x04,
      0xf9, 0x0d, 0xf6, 0x44, 0x5b, 0x46, 0xdb, 0xde, 0xb7, 0x7b, 0xf4, 0xac, 0x3b, 0x7f, 0x36, 0x0d,
      0x90, 0x7c, 0x2c, 0xb0, 0x20, 0x48, 0xab, 0xa9, 0x7f, 0x39, 0xdb, 0x6d, 0x0b, 0x80, 0xe2, 0xf1,
      0x37, 0x50, 0xfa, 0x83, 0x9d, 0xd3, 0x3e, 0x8c, 0x54, 0x48, 0xeb, 0xe7, 0x92, 0x34, 0x6a, 0xeb,
      0x2b, 0x18, 0xda, 0xda, 0xe5, 0x7c, 0x7e, 0xd3, 0x3d, 0xd9, 0xb1, 0xfd, 0x90, 0x28, 0xcd, 0x00,
      0x45, 0x93, 0xb3, 0x86, 0xeb, 0x32, 0x4b, 0xe6, 0xea, 0x24, 0xb6, 0x97, 0xb4, 0x11, 0x94, 0xa0,
      0x16, 0x53, 0xfb, 0xae, 0xa6, 0xd7, 0x9a, 0xe9, 0xd9, 0xfb, 0xa6, 0x41, 0xc2, 0x6d, 0xec, 0x4b,
      0x0b, 0x59, 0xd7, 0x6c, 0x2e, 0xec, 0x9b, 0x5d, 0x6f, 0x76, 0x66, 0xcb, 0xb0, 0x23, 0xca, 0x2c,
      0x8d, 0xb6, 0x3a, 0x6e, 0xdc, 0x29, 0xd1, 0xbd, 0x1d, 0x89, 0x3f, 0xeb, 0xc7, 0x22, 0x09, 0xb8,
      0x1d, 0x2e, 0x04, 0x98, 0x71, 0x1a, 0x35, 0x26, 0x7d, 0xaa, 0xf2, 0xdb, 0xc0, 0x01, 0x8a, 0x56,
      0x76, 0xd1, 0x27, 0xa3, 0x2b, 0xc8, 0x58, 0xea, 0x76, 0x72, 0xe6, 0xf9, 0xea, 0xa0, 0x54, 0xf4,
      0xb2, 0xa4, 0xc0, 0xbb, 0xec, 0x54, 0x81, 0x3f, 0x58, 0x37, 0x3c, 0x69, 0x45, 0xc8, 0xb7, 0xb1,
      0x60, 0x3b, 0x3d, 0x20, 0x5b, 0x97, 0xce, 0xd2, 0xfc, 0xb1, 0xf2, 0xaf, 0xa2, 0xcb, 0x67, 0x74,
      0xad, 0x58, 0x79, 0xc8, 0xfe, 0xc1, 0x54, 0x71, 0xea, 0x98, 0x0b, 0x59, 0xc6, 0x21, 0xa0, 0x94,
      0x7f, 0x91, 0xde, 0xfd, 0x61, 0xfc, 0x3c, 0xa1, 0x71, 0x47, 0x9f, 0x97, 0x89, 0x0d, 0x43, 0x74,
      0x97, 0xec, 0x85, 0xfe, 0x2e, 0x0d, 0xe7, 0x49, 0xca, 0x55, 0x0e, 0xdd, 0xf4, 0x38, 0xf8, 0x22,
      0xb1, 0x7e, 0x55, 0x9e, 0x56, 0xea, 0x0f, 0x4a, 0x3a, 0x3d, 0x0f, 0x86, 0x64, 0x57, 0x51, 0xf9,
      0xa3, 0x0c, 0x23, 0xe4, 0x2a, 0x6a, 0xdf, 0x20, 0x31, 0xf8, 0xdd, 0x6d, 0xa8, 0xc4, 0xdf, 0x42,
      0x7d, 0xae, 0xd2, 0xac, 0x7d, 0xd7, 0x1f, 0x85, 0x67, 0xa4, 0x4f, 0x97, 0x21, 0x25, 0x61, 0xd0,
      0xa9, 0x6b, 0x77, 0x47, 0xc7, 0x97, 0x47, 0x13, 0x03, 0x1a, 0xfa, 0xc8, 0xe2, 0x05, 0xd7, 0xa6,
      0x0e, 0xda, 0x71, 0x18, 0x42, 0xc5, 0xaa, 0xd8, 0xb0, 0x96, 0x53, 0x2f, 0xd3, 0x78, 0xad, 0x8f,
      0x2b, 0xc4, 0x91, 0x3b, 0x07, 0xd7, 0x90, 0x09, 0xcb, 0x55, 0xcc, 0xf7, 0xcc, 0xbd, 0xcf, 0xc5,
      0x3b, 0xc1, 0x34, 0x1d, 0x35, 0x3c, 0x59, 0x8d, 0x75, 0x35, 0xf7, 0xf7, 0xb7, 0xdb, 0xd6, 0x90,
      0x53, 0xdb, 0x66, 0x20, 0x0e, 0xf7, 0x98, 0xb0, 0xbd, 0x51, 0xa4, 0x49, 0xb4, 0x3f, 0x1d, 0xe2,
      0x82, 0x2b, 0x04, 0x3c, 0x13, 0x4b, 0x39, 0xb6, 0xbd, 0xa8, 0x00, 0xe7, 0x33, 0x60, 0xe5, 0xfa,
      0xf1, 0x7b, 0xd5, 0x9b, 0x2b, 0x4c, 0x9f, 0x81, 0xb6, 0xb9, 0xb8, 0x55, 0x16, 0x5f, 0x7a, 0x05,
      0x07, 0xe6, 0xb3, 0x3e, 0xbc, 0x8b, 0xc3, 0x2f, 0x37, 0x23, 0x19, 0x39, 0xd1, 0xa2, 0x4c, 0xba,
      0x81, 0x78, 0xa3, 0x99, 0xd3, 0xb0, 0x53, 0xb9, 0x38, 0x44, 0x2b, 0xfc, 0x8f, 0x7b, 0x0f, 0xfe,
      0x99, 0xca, 0xfb, 0x37, 0x3e, 0x1d, 0xd4, 0x99, 0x3c, 0xdd, 0xd5, 0x6f, 0x48, 0xc2, 0xe1, 0x83,
      0x23, 0xab, 0x7f, 0x52, 0xa9, 0x89, 0xc4, 0x61, 0x6f, 0xae, 0x02, 0x66, 0xe9, 0x7a, 0x67, 0x67,
      0xad, 0xb7, 0x80, 0x7f, 0xc8, 0xa8, 0xb5, 0x61, 0xc9, 0x1a, 0xb3, 0x57, 0x73, 0x6c, 0xe9, 0xd3,
      0xa0, 0xfa, 0xfe, 0x43, 0x70, 0xc3, 0x71, 0x46, 0x2e, 0xbe, 0x2e, 0x02, 0x17, 0xca, 0x78, 0xa0};

		//closed beta
		static byte[] table2 = {
      0x86, 0xFA, 0x1A, 0x1C, 0x07, 0xBD, 0xD8, 0x64, 0xCE, 0xEE, 0x59, 0x88, 0xCD, 0xA9, 0x1D, 0x06,
      0xF7, 0x3D, 0x31, 0x58, 0x83, 0xA1, 0x5C, 0x7E, 0xDF, 0xA6, 0x50, 0x9E, 0x89, 0xA8, 0x12, 0xD2,
      0x25, 0x49, 0x75, 0xE2, 0x07, 0x0F, 0xEB, 0x01, 0x97, 0x4A, 0x66, 0x35, 0xAB, 0x32, 0x9D, 0xA7,
      0x4E, 0xA2, 0x89, 0x62, 0x0F, 0x55, 0x41, 0xC5, 0x52, 0x10, 0x1F, 0x47, 0xB0, 0xA0, 0x63, 0xA6,
      0xF0, 0x1C, 0x1C, 0x4C, 0x9B, 0x3C, 0xAC, 0xE2, 0xB3, 0x4E, 0x9F, 0xF1, 0xA4, 0x91, 0x29, 0x82,
      0xE4, 0x76, 0x0D, 0x8D, 0x4F, 0xA3, 0x34, 0x4A, 0xCC, 0x1C, 0xC7, 0x18, 0x48, 0x8E, 0xFE, 0x18,
      0x79, 0x08, 0x87, 0x28, 0x8E, 0x24, 0xB7, 0x6B, 0x38, 0xF2, 0x58, 0x01, 0x2D, 0xA8, 0x58, 0x0E,
      0x9C, 0x54, 0x29, 0xCF, 0xA1, 0xAE, 0x0A, 0xD2, 0x3B, 0x4A, 0x10, 0xF8, 0xD8, 0x19, 0x31, 0x7D,
      0xF3, 0xAE, 0x1B, 0x90, 0xD2, 0x2F, 0x16, 0xC7, 0xE5, 0x3B, 0xCC, 0xEF, 0xE1, 0xE1, 0x2C, 0x86,
      0x00, 0xDD, 0x35, 0x67, 0x8D, 0x25, 0xFC, 0xED, 0x32, 0x1F, 0xA9, 0x1A, 0x12, 0x6D, 0xB0, 0xF7,
      0x3D, 0xB6, 0x1F, 0xE8, 0x81, 0x4D, 0x36, 0xE7, 0x25, 0x30, 0x21, 0x90, 0x86, 0x30, 0x0E, 0xEE,
      0x40, 0xBE, 0x6E, 0xDA, 0xC1, 0x3A, 0xAF, 0xF2, 0xEC, 0x28, 0x2C, 0xF1, 0xCD, 0x44, 0x98, 0x72,
      0xDA, 0xCD, 0xC6, 0xD9, 0xDF, 0xF7, 0xEE, 0x88, 0x04, 0xE1, 0x62, 0x00, 0x08, 0x0E, 0xCD, 0x16,
      0x37, 0xAB, 0xF9, 0xF5, 0x14, 0xAA, 0x2E, 0x00, 0x4E, 0xF8, 0x18, 0x41, 0x0B, 0xD9, 0x6F, 0x9B,
      0xFA, 0xAD, 0x2B, 0x54, 0x56, 0x2E, 0x7F, 0x2C, 0x3B, 0x6A, 0x82, 0xA1, 0x7C, 0x7C, 0xA6, 0x8F,
      0x66, 0x5E, 0xE7, 0xCF, 0x83, 0xB9, 0xEA, 0xFC, 0xE2, 0x31, 0xD4, 0x10, 0xF3, 0xF4, 0x22, 0xEC,
      0x73, 0x14, 0x4F, 0x94, 0x78, 0x79, 0x8F, 0x1E, 0x29, 0xEA, 0x5F, 0x21, 0x1E, 0x08, 0x37, 0xB8,
      0xF6, 0x9A, 0x2D, 0xC5, 0x36, 0x34, 0xC1, 0x97, 0xDC, 0x75, 0xB2, 0xAD, 0xD7, 0xE3, 0x04, 0xA7,
      0xC0, 0xC9, 0x1C, 0x1A, 0x00, 0xE9, 0x2D, 0x6F, 0xD6, 0x8D, 0xBC, 0x73, 0x52, 0xC0, 0x8A, 0xB6,
      0xBA, 0x2C, 0xA6, 0x7D, 0x7B, 0x6F, 0xF4, 0x47, 0x1A, 0x72, 0xE9, 0xB2, 0x30, 0x7D, 0xD4, 0xD3,
      0x09, 0x9C, 0x65, 0xB0, 0xD0, 0x17, 0xCF, 0xFC, 0xF2, 0xFF, 0x46, 0xD2, 0xA6, 0x43, 0x11, 0x76,
      0x2B, 0xE5, 0x1D, 0xE5, 0xC9, 0x47, 0x2F, 0x4B, 0x1B, 0xDD, 0x9A, 0xFD, 0x9D, 0x20, 0xB6, 0x43,
      0x1A, 0x64, 0xE3, 0x68, 0xF3, 0x21, 0x57, 0x68, 0xD4, 0x04, 0x8F, 0xC3, 0xCE, 0xAF, 0xA3, 0xAB,
      0x69, 0xA3, 0x3C, 0x34, 0xBE, 0x1F, 0x84, 0xA8, 0x0E, 0x74, 0xCB, 0xB7, 0xE6, 0xB1, 0x39, 0x8D,
      0x68, 0x00, 0x3A, 0x9B, 0x9C, 0xB1, 0x09, 0x1C, 0x7D, 0x52, 0x15, 0x12, 0xA6, 0xB0, 0x83, 0xD3,
      0x40, 0x47, 0x9B, 0xE4, 0x22, 0xE3, 0x6E, 0x30, 0xC4, 0xFC, 0x6F, 0x4F, 0xFE, 0x9F, 0x51, 0x14,
      0x13, 0x57, 0xF1, 0xEB, 0x25, 0xF7, 0x95, 0x4C, 0x92, 0xB6, 0x3C, 0xD0, 0x34, 0x79, 0x59, 0x33,
      0x20, 0xBE, 0xB8, 0xBF, 0xE0, 0x0A, 0xD2, 0x77, 0xBC, 0x43, 0x5C, 0x7D, 0xFC, 0xE1, 0x59, 0x00,
      0xDE, 0x5A, 0x7D, 0x44, 0x11, 0xAC, 0x13, 0xF2, 0x64, 0x84, 0x4F, 0x5D, 0xA2, 0xC4, 0x36, 0xD7,
      0x23, 0xFA, 0xF8, 0xD1, 0x14, 0x8D, 0xF9, 0xDD, 0x17, 0x1D, 0x52, 0x41, 0x22, 0xF5, 0x1A, 0x42,
      0x39, 0xFE, 0x36, 0xD5, 0x0A, 0x10, 0x01, 0xD2, 0xEA, 0x12, 0x82, 0x5A, 0x48, 0xD2, 0x94, 0x95,
      0x0A, 0xF7, 0xAB, 0x70, 0xF7, 0xF2, 0x98, 0x89, 0xA1, 0x68, 0xF9, 0xE1, 0xD6, 0xE1, 0xBD, 0x92,
      0x38, 0x45, 0x5F, 0x19, 0xE2, 0xEA, 0x46, 0x76, 0xC5, 0xC3, 0xF2, 0xB4, 0x9F, 0x70, 0x53, 0x09,
      0x3F, 0xB8, 0x06, 0x3A, 0xF3, 0x46, 0xC8, 0x6A, 0xCD, 0x0A, 0xE3, 0xF0, 0xAA, 0x34, 0xD9, 0x72,
      0x98, 0x34, 0x23, 0xD1, 0x96, 0x8C, 0x32, 0x32, 0x3B, 0x00, 0xA3, 0x9E, 0x4F, 0xED, 0xBC, 0x97,
      0xD4, 0x4A, 0x26, 0x15, 0x96, 0x1D, 0x0E, 0x36, 0xB8, 0xEE, 0x86, 0x45, 0x57, 0x04, 0x6D, 0x2B,
      0xC0, 0xDB, 0x91, 0x0A, 0x46, 0xCE, 0x7C, 0x1F, 0x3C, 0x3A, 0x81, 0x94, 0x22, 0x26, 0x82, 0x6D,
      0x83, 0xBD, 0x13, 0x2D, 0x96, 0x91, 0x53, 0x6C, 0x26, 0x0C, 0x44, 0xFE, 0xBD, 0xEE, 0xDA, 0xCC,
      0xBD, 0x52, 0xA6, 0x11, 0x3E, 0x10, 0x42, 0x20, 0x60, 0xEB, 0x5F, 0x5B, 0x0D, 0x7C, 0xBB, 0x80,
      0xAC, 0x2F, 0xB9, 0xF9, 0xD2, 0x4A, 0xEB, 0x54, 0x80, 0x60, 0x62, 0x85, 0xE5, 0x1A, 0xF0, 0x30,
      0x45, 0xB7, 0x44, 0x82, 0xEF, 0x3A, 0x0C, 0xE0, 0xE5, 0x94, 0xFA, 0xFD, 0x2E, 0xD9, 0xEB, 0x8D,
      0x5A, 0xC2, 0xEF, 0x39, 0x51, 0x71, 0x92, 0xFA, 0xDB, 0xEF, 0x14, 0x88, 0x00, 0xFF, 0xE3, 0xF6,
      0xB5, 0x34, 0x34, 0x40, 0xF5, 0xBB, 0xC8, 0xD3, 0xB5, 0xBD, 0xF6, 0xCF, 0xC7, 0xB1, 0xF9, 0x18,
      0x3D, 0xA2, 0x74, 0xEF, 0x40, 0xBC, 0x6B, 0x39, 0xF2, 0xC8, 0x6E, 0x00, 0x64, 0x78, 0x52, 0x88,
      0x13, 0xF4, 0x27, 0x74, 0x14, 0x8F, 0xCE, 0x34, 0x5E, 0xF9, 0xE0, 0x6D, 0x47, 0xFC, 0x38, 0x6D,
      0xB0, 0x03, 0xED, 0x6C, 0xF6, 0x68, 0x00, 0xAC, 0x2B, 0xFE, 0x73, 0x2C, 0x94, 0x9E, 0x3F, 0x17,
      0x0C, 0x33, 0xB9, 0x8F, 0x33, 0x34, 0xDE, 0x05, 0x18, 0xE1, 0x2B, 0xB9, 0x42, 0x3F, 0x5F, 0xA2,
      0xB4, 0x1E, 0xE9, 0x45, 0xF3, 0x38, 0x43, 0xBB, 0x8E, 0xB0, 0x0A, 0x94, 0x39, 0xEE, 0xFF, 0x9A,
      0xF4, 0x2D, 0x6C, 0x4B, 0x66, 0xB1, 0x1E, 0x0F, 0xC2, 0x18, 0x32, 0xE1, 0x74, 0xFF, 0x90, 0x94,
      0xF2, 0x38, 0xDD, 0x56, 0xDC, 0x78, 0x91, 0x96, 0xD1, 0x04, 0x03, 0x09, 0x21, 0x39, 0xB2, 0xD4,
      0xCC, 0x2A, 0xA8, 0xAB, 0xE8, 0x99, 0x1C, 0xE7, 0xE4, 0x43, 0x3B, 0x58, 0xC1, 0x59, 0x54, 0xE8,
      0xBD, 0x9C, 0x28, 0xC6, 0x81, 0xFC, 0xAD, 0x33, 0x4F, 0x24, 0x16, 0xA0, 0x47, 0xD1, 0x4C, 0x4D,
      0x39, 0x7A, 0xC1, 0xF7, 0x1D, 0x04, 0xCF, 0xE7, 0xAE, 0x17, 0x71, 0xD9, 0x37, 0xDC, 0x9C, 0x0A,
      0x0E, 0x9D, 0x0E, 0x04, 0xD7, 0x24, 0xC1, 0x50, 0x0C, 0x49, 0xE3, 0xBC, 0xCA, 0x98, 0x89, 0x55,
      0x86, 0x73, 0xF1, 0xC3, 0x8D, 0x8F, 0x99, 0x34, 0xF7, 0x4B, 0xE7, 0x69, 0x0A, 0xB0, 0xC1, 0x2F,
      0x85, 0x97, 0xBF, 0xC3, 0xFD, 0xD0, 0x62, 0x75, 0xB1, 0xAD, 0xF3, 0x04, 0xF3, 0xF3, 0x77, 0x06,
      0xAA, 0x77, 0x5A, 0xE7, 0xEB, 0x67, 0x3F, 0xB5, 0x40, 0xA1, 0x9C, 0x53, 0x96, 0xFD, 0x85, 0x53,
      0x6E, 0xED, 0x52, 0x05, 0x3B, 0x6E, 0x89, 0xEF, 0x95, 0x98, 0xB6, 0x66, 0x34, 0xD0, 0x8A, 0x3F,
      0x44, 0xEA, 0x06, 0x86, 0x13, 0x39, 0xEF, 0x20, 0xAD, 0xE4, 0x73, 0x2C, 0x61, 0x77, 0x10, 0x3D,
      0xB9, 0x0B, 0xC2, 0x0C, 0xFD, 0xF2, 0x99, 0xD8, 0xB1, 0x57, 0x83, 0x1B, 0x24, 0xA6, 0xA0, 0xAB,
      0x97, 0x3E, 0xE5, 0x09, 0x07, 0x3F, 0x43, 0xED, 0x12, 0xE3, 0x36, 0xCE, 0x16, 0x58, 0xF2, 0x78,
      0x00, 0x63, 0xF7, 0x67, 0xDC, 0xD9, 0x5F, 0x0D, 0xAA, 0x3E, 0x9A, 0xA3, 0x83, 0x72, 0xFE, 0xBA,
      0x92, 0xE9, 0xD4, 0x22, 0xF0, 0x38, 0x38, 0x61, 0xE2, 0x79, 0x9B, 0x5E, 0x8A, 0x62, 0x27, 0x59,
      0x84, 0x71, 0xC0, 0xEB, 0x95, 0x28, 0x0D, 0x34, 0xCB, 0xAB, 0x25, 0xC6, 0x3B, 0xBC, 0x52, 0xA5,
      0xCA, 0x6B, 0x93, 0xCA, 0x23, 0x6D, 0x35, 0x87, 0x41, 0x87, 0x3E, 0x48, 0xB9, 0xDF, 0x0E, 0xFD,
      0x30, 0xB8, 0xD1, 0xB8, 0x10, 0x68, 0x3D, 0xBC, 0x09, 0x04, 0x31, 0x94, 0x5C, 0x91, 0xAF, 0x6C};
	}
}
